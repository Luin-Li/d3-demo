<!DOCTYPE html>
<html lang="zh-cn">
  <meta charset="utf-8">
  <style>
    
  </style>
  <body>
    <textarea rows="5" cols="100" id="node-data">
        (山竹, TYPE, 农作物)(山竹, TYPE, 水果)(山竹, TYPE, 热带水果)(山竹, TYPE, 金丝桃科)(山竹, TYPE, 植物)(榴梿属, TYPE, 水果)(榴梿属, TYPE, 榴莲属)(特小凤, TYPE, 水果)(特小凤, TYPE, 植物)(柿, TYPE, 农作物)(柿, TYPE, 中草药)(柿, TYPE, 水果)(柿, TYPE, 柿科)(柿, TYPE, 食品)(葡萄, TYPE, 水果)(葡萄, TYPE, 葡萄)(葡萄, TYPE, 汉语外来词)(葡萄, TYPE, 药用植物)
    </textarea>
    <svg class="logo" width="1000" height="1000"></svg>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
      let svg = d3.select('svg')
      let network_g = svg.append('g').attr('transform','translate(500,500)')
      let color = d3.scaleOrdinal(d3.schemeSet3)
  
      let totalData = [
        ['山竹'],
        ['农作物','水果',' 植物','金丝桃科'],
        ['葡萄','柿','番石榴','榴莲'],
        ['酸枣','椰子','黑水西瓜']
      ]

      let nodes = [{id: '山竹', strong: 8, index: 0}]
      let links = []

      const getNodeData = (id, index) => {
        return {id, strong: 5, index}
      }

      let allDataByKey = []
      const getAllKeyData = (() => { // 输入框数据按关键词分组
        let dataVal = document.getElementById('node-data').value
        const keyDataReg = /[^(]+(?=\))/g
        let list = dataVal.match(keyDataReg)
        let currentKey = ''
        let currentKeyIndex = -1
        list.forEach((item) => {
          let oneGroup = item.split(', ')
          if (currentKey !== oneGroup[0]) {
            currentKey = oneGroup[0]
            currentKeyIndex++
            allDataByKey.push([currentKey,[oneGroup[2]]])
            return true
          }
          allDataByKey[currentKeyIndex][1].push(oneGroup[2])
        })
      })()

      const initData = () => {
        // 中心点
        let firstSource = {id: allDataByKey[0][1], strong: 8, index: 0}
        nodes.push(firstSource)
        allDataByKey[0][1].forEach((item,index) => {
          let currentTarget = getNodeData(item, index+1)
          nodes.push(currentTarget)
          links.push({source: firstSource, target: currentTarget})
        })
      } 
      
      let [activeNode, activeNodeGroup] = [0, [0, 2, 1]]
      let activeDataGroup = 1


      let network = d3.forceSimulation(nodes)
                      .force('charge',d3.forceManyBody().strength(-500))
                      .force('link',d3.forceLink(links).distance(300))
                      .force("x", d3.forceX())
                      .force("y", d3.forceY())
                      .alphaTarget(1)
                      .on("tick", ticked)
      
      let network_g_node = network_g.append('g').attr("stroke", "#000")
                                    .selectAll('.node')
      let network_g_node_circle = network_g_node.selectAll('.node-circle')                             
      let network_g_node_text = network_g_node.selectAll('.node-text')                             

      let network_g_link = network_g.append('g')
                                    .attr("stroke", "#bdbdbd")
                                    .selectAll('.link')

      const restart = () => {
        network_g_node = network_g_node.data(nodes, (d) => {return d.id})
        // network_g_node.exit().remove()
        let old_network_g_node = network_g_node
        network_g_node = network_g_node.enter().append('g') // 新数据

        network_g_node_circle = network_g_node.append('circle')
          .attr('fill',(d) => {
            return color(d.id)
          })
          .attr('r',(d) => {
            return d.strong
          }).merge(network_g_node_circle)   

        network_g_node_text = network_g_node.append('text')
          .attr('dy','.35em')
          .text((d) => {return d.id}).merge(network_g_node_text)

        network_g_link = network_g_link.data(links,(d) => {return `${d.source.id}-${d.target.id}`})
        network_g_link.exit().remove()
        network_g_link = network_g_link.enter().append('line').merge(network_g_link)

        network.nodes(nodes)
        network.force('link',d3.forceLink(links).distance(80))
        network.alpha(1).restart()
        // 新数据加旧数据
        network_g_node = network_g_node.merge(old_network_g_node)
      }

      restart()

      let nodeInterval = d3.interval(() => {
        // 无下一个动作点
        if ((activeDataGroup - 1) === activeNodeGroup.length) {
          nodeInterval.stop()
          return false
        }

        let currentSource = nodes[activeNode]
        totalData[activeDataGroup].forEach((data) => {
          let index = nodes.length
          let currentTarget = getNodeData(data, index)
          nodes.push(currentTarget)
          links.push({source: currentSource, target: currentTarget})
          // nodes[0].strong = nodes[0].strong + 10
        })
        activeNode = activeNodeGroup[activeDataGroup++]
        restart()
      }, 2000, d3.now() + 1000)

      function ticked() {
        network_g_node_circle.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
        network_g_node_text.attr("x", function(d) { return d.x; })
            .attr("y", function(d) { return d.y; })

        network_g_link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
      }

    </script>
</body>
</html>